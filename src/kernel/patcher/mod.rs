//! Kernel patch application with LTO shielding and CONFIG management.
//!
//! # Cooperative Kernel Build Pipeline
//! This module implements a hook-based patcher that works with the kernel's native
//! configuration and build systems, avoiding fights with `make` and solving the
//! module oscillation issue.
//!
//! ## Core Concepts
//! - **PatchHook**: Phase-aware patching system that runs at specific build phases
//! - **.config.override**: Native KConfig injection via `KCONFIG_ALLCONFIG` env var
//! - **Sanitized Environment**: Clean toolchain execution without $srcdir leaks
//!
//! # External Workspace Architecture (Cross-Mount Support)
//!
//! ## Problem: Multi-Mount Kernel Builds
//! The GOATd Kernel application supports external workspaces on different filesystems/mount points:
//! - **App directory**: `/home/madgoat/Documents/GOATd Kernel/` (on System NVME, EXT4)
//! - **Build workspace**: `/mnt/Optane/goatd/` (on Scratch NVME, XFS for wear leveling)
//!
//! This separation enables:
//! - NVME wear leveling by avoiding repetitive writes on System NVME
//! - Faster build performance with dedicated scratch disk
//! - Logical separation of project code and build artifacts
//!
//! ## Critical Challenge: File Discovery Across Mounts
//! During kernel build, `.kernelrelease` is generated by the build system in the kernel source tree.
//! However, the `package()` function (running in fakeroot) must locate and read this file.
//!
//! **The Problem**:
//! - Kernel source is in workspace root: `/mnt/Optane/goatd/` (external mount)
//! - Build artifacts (`.kernelrelease`) are created during `make`
//! - The `package()` function runs with modified root directory (fakeroot)
//! - Environment variable `PWD` may not reflect actual filesystem location in fakeroot
//! - Relative paths fail when switching between app dir and workspace dir
//!
//! ## Solution: 5-Level Fallback Strategy with Shell Injection
//! The patcher injects robust shell code into PKGBUILD functions that locates `.kernelrelease`
//! using a prioritized fallback strategy. This ensures the package() function can ALWAYS find
//! the kernel version, even across mount point boundaries and in fakeroot execution:
//!
//! ```bash
//! # PRIORITY 1: Check local directory (build artifact in current dir)
//! if [ -f .kernelrelease ]; then
//!     _actual_ver=$(cat .kernelrelease)
//! fi
//!
//! # PRIORITY 2: Search srcdir and subdirectories (makepkg scenarios)
//! if [ -z "${_actual_ver}" ]; then
//!     _rel_file=$(find "${srcdir}" -maxdepth 2 -name .kernelrelease -print -quit)
//!     [ -n "${_rel_file}" ] && _actual_ver=$(cat "${_rel_file}")
//! fi
//!
//! # PRIORITY 3: Environment variable fallback (set by executor)
//! if [ -z "${_actual_ver}" ] && [ -n "${GOATD_KERNELRELEASE}" ]; then
//!     _actual_ver="${GOATD_KERNELRELEASE}"
//! fi
//!
//! # PRIORITY 4: Scan pkgdir for modules directory
//! if [ -z "${_actual_ver}" ]; then
//!     _actual_ver=$(ls "${pkgdir}/usr/lib/modules/" | grep -v extramodules | head -1)
//! fi
//!
//! # PRIORITY 5: Fallback to standard naming convention
//! [ -z "${_actual_ver}" ] && _actual_ver="${_kernver}"
//! ```
//!
//! ## Environment Variable Security
//! The `GOATD_KERNELRELEASE` environment variable:
//! - Is exported by `executor.rs` after successful kernel build
//! - Survives fakeroot execution (unlike `PWD`)
//! - Provides PRIORITY 3 fallback when file cannot be found
//! - Is set unconditionally to enable seamless cross-mount scenarios
//! - Lives in the executor, not the patcher, to maintain separation of concerns
//!
//! ## Shell Code Injection Points
//! The patcher injects dynamic shell code at multiple PKGBUILD phases:
//! - **prepare()**: Modprobed-db discovery, whitelist enforcement, post-setting-config restoration
//! - **build()**: LTO hard enforcer (PHASE G1), post-oldconfig re-enforcement (PHASE E1)
//! - **_package() and _package_headers()**: Unified header naming (PHASE E2) with .kernelrelease detection
//!
//! Each injection point includes comprehensive logging with `[PHASE-*]` tags for debugging.
//!
//! ## Future Development Notes
//! - Monitor shell code execution logs for path resolution failures
//! - Add metrics for fallback strategy effectiveness across different mount configurations
//! - Consider adding `GOATD_WORKSPACE_ROOT` environment variable for explicit workspace location
//! - Implement workspace health checks during preparation to verify mount accessibility
//! - Add warnings when workspace is on slow storage (fallback detection)

pub mod env;
pub mod kconfig;
pub mod pkgbuild;
pub mod templates;

use crate::error::PatchError;
use crate::hardware::gpu;
use crate::kernel::lto;
use crate::models::GpuVendor;
use once_cell::sync::Lazy;
use regex::Regex;
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use std::process::Command;

/// Phase-aware patch hook system
///
/// Defines when and how patches are applied during the kernel build lifecycle.
/// Instead of fighting the make system, we inject configuration at the right phases.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PatchPhase {
    /// Before any kernel configuration (early .config setup)
    PreConfig,
    /// During oldconfig/syncconfig (native KConfig processing)
    ConfigProcessing,
    /// Before make command (final enforcement gate)
    PreBuild,
    /// After oldconfig (re-enforcement after kernel revert)
    PostOldconfig,
}

/// Individual patch hook definition
///
/// Represents a discrete, idempotent patch operation that applies at a specific phase.
/// Multiple hooks can compose the full patching strategy.
#[derive(Debug, Clone)]
pub struct PatchHook {
    /// Which phase this hook applies to
    pub phase: PatchPhase,
    /// Unique identifier for this hook (for deduplication)
    pub id: String,
    /// Description of what this hook does
    pub description: String,
    /// Whether this hook is enabled (phase may be skipped)
    pub enabled: bool,
    /// Configuration options to inject (will be put in .config.override)
    pub config_options: HashMap<String, String>,
}

impl PatchHook {
    /// Create a new patch hook with default settings
    pub fn new(phase: PatchPhase, id: &str, description: &str) -> Self {
        PatchHook {
            phase,
            id: id.to_string(),
            description: description.to_string(),
            enabled: true,
            config_options: HashMap::new(),
        }
    }

    /// Add a CONFIG option to be injected by this hook
    pub fn with_config(mut self, key: &str, value: &str) -> Self {
        self.config_options
            .insert(key.to_string(), value.to_string());
        self
    }
}

// Pre-compiled regex patterns (compiled once at startup)
static FLTO_THIN_REGEX: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"\s*-flto=thin\s*").expect("Invalid -flto=thin regex"));
static FLTO_FULL_REGEX: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"\s*-flto=full\s*").expect("Invalid -flto=full regex"));
static ICF_REGEX: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"\s*--icf[=a-zA-Z0-9]*\s*").expect("Invalid --icf regex"));
static SPACE_CLEANUP_REGEX: Lazy<Regex> =
    Lazy::new(|| Regex::new(r" {2,}").expect("Invalid space cleanup regex"));
static CC_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?m)^\s*(?:export\s+)?CC\s*=\s*(?:gcc|cc)[^\n]*").expect("Invalid CC regex")
});
static CXX_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?m)^\s*(?:export\s+)?CXX\s*=\s*(?:g\+\+|c\+\+)[^\n]*").expect("Invalid CXX regex")
});
static LD_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?m)^\s*(?:export\s+)?LD\s*=\s*(?:ld)[^\n]*").expect("Invalid LD regex")
});
static LTO_REMOVAL_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?m)^(?:CONFIG_LTO_|CONFIG_HAS_LTO_|# CONFIG_LTO_|# CONFIG_HAS_LTO_)[^\n]*$")
        .expect("Invalid LTO removal regex")
});
static SPACE_COLLAPSE_REGEX: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"\n\n+").expect("Invalid space collapse regex"));
static MAKE_REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"\bmake\b").expect("Invalid make regex"));
static GCC_PATTERN_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?m)^\s*(?:export\s+)?(GCC|CFLAGS|CXXFLAGS|LDFLAGS)_[A-Z0-9_]*\s*=")
        .expect("Invalid GCC pattern regex")
});
static OLDCONFIG_PATTERN: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?m)(make\s+(?:old)?config|make\s+syncconfig)")
        .expect("Invalid oldconfig pattern regex")
});
static POLLY_REMOVAL_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?m)\s*# ===+\s*\n\s*# POLLY LOOP OPTIMIZATION.*?export LDFLAGS.*?\n")
        .unwrap_or_else(|_| {
            Regex::new(r"(?m)^\s*# POLLY LOOP OPTIMIZATION.*?^export LDFLAGS").unwrap()
        })
});
static G1_REMOVAL_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?m)\s*# ===+\s*\n\s*# PHASE G1 PREBUILD:.*?fi\s*\n")
        .unwrap_or_else(|_| Regex::new(r"(?m)^\s*# PHASE G1 PREBUILD.*?^fi\s*$").unwrap())
});
static E1_REMOVAL_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?m)\s*# ===+\s*\n\s*# PHASE E1 CRITICAL:.*?fi\s*\n")
        .unwrap_or_else(|_| Regex::new(r"(?m)^\s*# PHASE E1 CRITICAL.*?^fi\s*$").unwrap())
});
static NVIDIA_MAKE_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?m)^MAKE(\[\d+\])?\s*=\s*(.*)$").expect("Invalid NVIDIA MAKE regex")
});

/// Result type for patching operations
pub type PatchResult<T> = std::result::Result<T, PatchError>;

/// Find a toolchain binary in PATH, with LLVM-19 prioritization
///
/// Searches for the binary in this order:
/// 1. LLVM-19 variant (e.g., llvm-19-strip for strip) - HIGHEST PRIORITY
/// 2. LLVM variant without version (e.g., llvm-strip for strip)
/// 3. Standard location (e.g., /usr/bin/strip)
/// 4. Just the command name (let PATH search)
///
/// Returns the resolved command name to use
fn find_toolchain_binary(name: &str) -> String {
    // STEP 1: Try LLVM-19 variant first (highest priority for consistency)
    let llvm19_variant = format!("llvm-19-{}", name);
    if Command::new(&llvm19_variant)
        .arg("--version")
        .output()
        .is_ok()
    {
        eprintln!(
            "[Patcher] [TOOLCHAIN] Found LLVM-19 variant: {}",
            llvm19_variant
        );
        return llvm19_variant;
    }

    // STEP 2: Try generic LLVM variant (fallback for latest LLVM)
    let llvm_variant = format!("llvm-{}", name);
    if Command::new(&llvm_variant)
        .arg("--version")
        .output()
        .is_ok()
    {
        eprintln!("[Patcher] [TOOLCHAIN] Found LLVM variant: {}", llvm_variant);
        return llvm_variant;
    }

    // STEP 3: Try standard /usr/bin location
    let standard_path = format!("/usr/bin/{}", name);
    if std::path::Path::new(&standard_path).exists() {
        eprintln!(
            "[Patcher] [TOOLCHAIN] Found at standard location: {}",
            standard_path
        );
        return standard_path;
    }

    // STEP 4: Fallback to just the command name (rely on PATH)
    eprintln!(
        "[Patcher] [TOOLCHAIN] Using {} from PATH (final fallback)",
        name
    );
    name.to_string()
}

/// AMD GPU directories that require LTO shielding
const AMDGPU_SHIELD_DIRS: &[&str] = &[
    "drivers/gpu/drm/amd",
    "drivers/gpu/drm/amd/amdgpu",
    "drivers/gpu/drm/amd/amdkfd",
    "drivers/gpu/drm/amd/display",
];

/// Map of directory paths to their corresponding module names
fn get_module_name_for_dir(dir: &str) -> &'static str {
    match dir {
        "drivers/gpu/drm/amd" | "drivers/gpu/drm/amd/amdgpu" => "amdgpu",
        "drivers/gpu/drm/amd/amdkfd" => "amdkfd",
        "drivers/gpu/drm/amd/display" => "amdgpu_display",
        _ => "amdgpu",
    }
}

/// Find a source file in the kernel source tree, handling nested `src/` directories
///
/// This helper addresses the issue where `makepkg` extracts kernel sources into
/// a `src/linux-*/` subdirectory, rather than directly in the workspace root.
///
/// # Search Strategy
/// 1. **Direct root**: Check if file exists at `src_dir/relative_path`
/// 2. **Nested src/**: Recursively search `src_dir/src/` for matching file
/// 3. **Fallback**: Return original path if not found (caller can handle gracefully)
///
/// # Arguments
/// * `src_dir` - Base source directory (workspace root or kernel root)
/// * `relative_path` - Relative path to file (e.g., "include/linux/memremap.h")
///
/// # Returns
/// PathBuf representing the first matching file found, or original path if not found
fn find_source_file(src_dir: &PathBuf, relative_path: &str) -> PathBuf {
    // STRATEGY 1: Check root directory first
    let root_path = src_dir.join(relative_path);
    if root_path.exists() {
        eprintln!(
            "[Patcher] [FILE-DISCOVERY] Found {} at root: {}",
            relative_path,
            root_path.display()
        );
        return root_path;
    }

    // STRATEGY 2: Recursively search in src/ subdirectories (handles makepkg extraction)
    let src_subdir = src_dir.join("src");
    if src_subdir.exists() {
        if let Ok(entries) = fs::read_dir(&src_subdir) {
            for entry in entries.flatten() {
                let path = entry.path();
                // Look for nested file matching the relative path
                let nested_path = path.join(relative_path);
                if nested_path.exists() {
                    eprintln!(
                        "[Patcher] [FILE-DISCOVERY] Found {} in nested src/: {}",
                        relative_path,
                        nested_path.display()
                    );
                    return nested_path;
                }
            }
        }
    }

    // FALLBACK: Return original path (caller can handle with graceful degradation)
    eprintln!(
        "[Patcher] [FILE-DISCOVERY] [WARNING] Could not locate {} in root or src/ subdirectories",
        relative_path
    );
    root_path
}

/// High-level kernel patcher for orchestrator integration
///
/// Provides a clean API for applying all kernel patches:
/// - LTO shielding for GPU drivers
/// - ICF flag removal
/// - Kconfig option application
pub struct KernelPatcher {
    /// Source directory of the kernel
    src_dir: PathBuf,
    /// Backup directory for original files
    backup_dir: PathBuf,
}

impl KernelPatcher {
    /// Create a new kernel patcher for the given source directory
    pub fn new(src_dir: PathBuf) -> Self {
        let backup_dir = src_dir.join(".kernel_patcher_backup");
        KernelPatcher {
            src_dir,
            backup_dir,
        }
    }

    /// Get the source directory (for trait methods in pkgbuild module)
    pub(crate) fn src_dir(&self) -> &PathBuf {
        &self.src_dir
    }

    /// Get the backup directory (for trait methods in pkgbuild module)
    pub(crate) fn backup_dir(&self) -> &PathBuf {
        &self.backup_dir
    }

    /// Cleans up old .pkg.tar.zst artifacts.
    pub fn cleanup_previous_artifacts(&self) -> PatchResult<u32> {
        let mut removed_count = 0u32;

        if let Ok(entries) = fs::read_dir(&self.src_dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if let Some(filename) = path.file_name() {
                    let name = filename.to_string_lossy();
                    // Remove any old .pkg.tar.zst files (both kernel and headers packages)
                    if name.ends_with(".pkg.tar.zst") {
                        match fs::remove_file(&path) {
                            Ok(()) => {
                                eprintln!("[Patcher] [CLEANUP] Removed old artifact: {}", name);
                                removed_count += 1;
                            }
                            Err(e) => {
                                eprintln!("[Patcher] [WARNING] Failed to remove {}: {}", name, e);
                                // Continue anyway - build will try to force overwrite
                            }
                        }
                    }
                }
            }
        }

        Ok(removed_count)
    }

    /// Finds built kernel artifacts (.pkg.tar.zst files and alternative images).
    ///
    /// Searches the kernel source directory for:
    /// 1. Arch package files (*.pkg.tar.zst) - primary artifacts from makepkg
    /// 2. Fallback kernel images (bzImage, vmlinuz, vmlinux) - for raw make builds
    ///
    /// # Returns
    /// Vector of PathBuf pointing to found artifacts, or empty vector if none found
    pub fn find_build_artifacts(&self) -> PatchResult<Vec<PathBuf>> {
        let mut artifacts = Vec::new();

        // PRIORITY 1: Look for .pkg.tar.zst files (Arch package format from makepkg)
        // Pattern: linux-*-x86_64.pkg.tar.zst (main kernel image)
        if let Ok(entries) = fs::read_dir(&self.src_dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if let Some(filename) = path.file_name() {
                    let name = filename.to_string_lossy().to_string();
                    // Look for the main linux kernel package or kernel headers
                    if (name.starts_with("linux-") && name.ends_with(".pkg.tar.zst"))
                        || (name.contains("linux-headers-") && name.ends_with(".pkg.tar.zst"))
                    {
                        eprintln!("[Patcher] [ARTIFACTS] Found kernel package: {}", name);
                        artifacts.push(path);
                    }
                }
            }
        }

        // PRIORITY 2: Fallback to common kernel image names if no packages found
        // This handles cases where raw kernel images were built instead of packages
        if artifacts.is_empty() {
            let possible_images = vec!["arch/x86/boot/bzImage", "vmlinuz", "vmlinux"];
            for image_name in possible_images {
                let image_path = self.src_dir.join(image_name);
                if image_path.exists() {
                    artifacts.push(image_path);
                    eprintln!("[Patcher] [ARTIFACTS] Found kernel image: {}", image_name);
                }
            }
        }

        Ok(artifacts)
    }

    /// Sanitize environment variables to prevent $srcdir leaks and toolchain contamination
    ///
    /// Removes or cleans environment variables that may contain:
    /// - $srcdir references (leaks into compiled output)
    /// - GCC/legacy compiler paths (conflicts with Clang/LLVM)
    /// - Unsafe temporary paths (build artifacts)
    ///
    /// CRITICAL FIX: Explicitly preserve /usr/bin and /bin to ensure make and other essential
    /// tools remain available after sanitization.
    ///
    /// # Arguments
    /// * `env_vars` - HashMap of environment variables to sanitize (mutated in-place)
    pub fn sanitize_build_environment(env_vars: &mut HashMap<String, String>) {
        // STEP 1: Remove variables that commonly leak $srcdir paths
        let srcdir_leak_patterns = vec![
            "TMPDIR", // Temporary directories often contain $srcdir
            "TEMP",   // Alternative temp
            "TMP",    // Short form
        ];

        for var_name in srcdir_leak_patterns {
            if let Some(_) = env_vars.remove(var_name) {
                eprintln!(
                    "[Patcher] [SANITIZE] Removed {} to prevent $srcdir leak",
                    var_name
                );
            }
        }

        // STEP 2: Clean up any GCC-related paths from PATH
        // CRITICAL FIX: Preserve /usr/bin and /bin to ensure make is available
        if let Some(path) = env_vars.get_mut("PATH") {
            let original_path = path.clone();
            let filtered: Vec<&str> = path
                .split(':')
                .filter(|p| {
                    // ALWAYS KEEP: Essential system directories for make and other tools
                    if *p == "/usr/bin" || *p == "/bin" || *p == "/usr/local/bin" {
                        return true;
                    }

                    // Remove only paths that contain gcc/llvm/clang installations
                    !(p.contains("/gcc")
                        || p.contains("/g++")
                        || p.contains("/cc")
                        || p.contains("/c++")
                        || p.contains("/llvm")
                        || p.contains("/clang"))
                        && !p.is_empty()
                })
                .collect();

            let new_path = filtered.join(":");
            if new_path != original_path {
                eprintln!("[Patcher] [SANITIZE] Cleaned PATH: removed GCC-related directories while preserving /usr/bin and /bin");
                *path = new_path;
            }
        }

        // STEP 3: Ensure CFLAGS/CXXFLAGS/LDFLAGS don't have GCC-specific markers
        for flag_var in &["CFLAGS", "CXXFLAGS", "LDFLAGS"] {
            if let Some(flags) = env_vars.get_mut(*flag_var) {
                let original = flags.clone();
                // Remove any GCC-specific flags
                *flags = flags
                    .replace("-Wl,--as-needed", "") // GCC linker marker
                    .replace("-Wl,--no-undefined", "") // GCC linker marker
                    .trim()
                    .to_string();

                if original != *flags {
                    eprintln!(
                        "[Patcher] [SANITIZE] Cleaned {}: removed GCC-specific flags",
                        flag_var
                    );
                }
            }
        }

        eprintln!("[Patcher] [SANITIZE] Environment sanitization complete");
    }

    /// Prepares purified build environment variables for toolchain enforcement.
    ///
    /// Centralizes environment variable setup to ensure:
    /// 1. LLVM/Clang compiler enforcement (CC=clang, CXX=clang++)
    /// 2. Linker and toolchain enforcement (LD=ld.lld, AR=llvm-ar, etc.)
    /// 3. HOST COMPILER enforcement (HOSTCC=clang, HOSTCXX=clang++)
    /// 4. PATH purification to prevent GCC/legacy compiler interference
    /// 5. Dynamic toolchain discovery (strip, llvm-strip, etc.)
    ///
    /// This method encapsulates all environment setup that previously lived in the Executor,
    /// ensuring the Executor only receives and applies pre-configured environment variables.
    ///
    /// # Arguments
    /// * `native_optimizations` - Whether to enable -march=native in KCFLAGS
    ///
    /// # Returns
    /// HashMap of environment variable names to values
    pub fn prepare_build_environment(&self, native_optimizations: bool) -> HashMap<String, String> {
        let mut env_vars = HashMap::new();

        // CRITICAL: Sanitize environment FIRST to remove leaked paths and GCC contamination
        eprintln!("[Patcher] [ENV] STEP 0: Sanitizing build environment for cleanliness");
        Self::sanitize_build_environment(&mut env_vars);

        // ============================================================================
        // CLANG/LLVM v19+ ENFORCEMENT
        // ============================================================================
        env_vars.insert("LLVM".to_string(), "1".to_string());
        env_vars.insert("LLVM_IAS".to_string(), "1".to_string());
        env_vars.insert("CC".to_string(), "clang".to_string());
        env_vars.insert("CXX".to_string(), "clang++".to_string());
        env_vars.insert("LD".to_string(), "ld.lld".to_string());

        // DYNAMIC TOOLCHAIN DISCOVERY: All toolchain binaries use LLVM-19 prioritization
        let ar_cmd = find_toolchain_binary("ar");
        env_vars.insert("AR".to_string(), ar_cmd);

        let nm_cmd = find_toolchain_binary("nm");
        env_vars.insert("NM".to_string(), nm_cmd);

        let strip_cmd = find_toolchain_binary("strip");
        env_vars.insert("STRIP".to_string(), strip_cmd);

        let objcopy_cmd = find_toolchain_binary("objcopy");
        env_vars.insert("OBJCOPY".to_string(), objcopy_cmd);

        let objdump_cmd = find_toolchain_binary("objdump");
        env_vars.insert("OBJDUMP".to_string(), objdump_cmd);

        let readelf_cmd = find_toolchain_binary("readelf");
        env_vars.insert("READELF".to_string(), readelf_cmd);
        env_vars.insert("GCC".to_string(), "clang".to_string());
        env_vars.insert("GXX".to_string(), "clang++".to_string());

        // ============================================================================
        // HOST COMPILER ENFORCEMENT - Ensure host tools also use Clang
        // ============================================================================
        env_vars.insert("HOSTCC".to_string(), "clang".to_string());
        env_vars.insert("HOSTCXX".to_string(), "clang++".to_string());
        eprintln!(
            "[Patcher] [ENV] Injected HOSTCC=clang, HOSTCXX=clang++ for host tool enforcement"
        );

        // ============================================================================
        // NATIVE OPTIMIZATIONS (-march=native support)
        // ============================================================================
        if native_optimizations {
            env_vars.insert("KCFLAGS".to_string(), "\"-march=native\"".to_string());
            eprintln!("[Patcher] [ENV] Injected KCFLAGS=\"-march=native\" for native host-optimized kernel compilation");
        } else {
            eprintln!(
                "[Patcher] [ENV] Native optimizations disabled, KCFLAGS not set to -march=native"
            );
        }

        eprintln!("[Patcher] [ENV] Prepared LLVM/Clang toolchain enforcement");

        // ============================================================================
        // PATH PURIFICATION: Remove LLVM-specific dirs to prevent interference
        // CRITICAL FIX: Preserve /usr/bin and /bin for make and essential tools
        // ============================================================================
        let llvm_bin_path = self.src_dir.join(".llvm_bin").to_string_lossy().to_string();
        let safe_paths = vec![llvm_bin_path.as_str(), "/usr/bin", "/bin", "/usr/local/bin"];

        let current_path = std::env::var("PATH").unwrap_or_default();
        let filtered_path: Vec<&str> = current_path
            .split(':')
            .filter(|p| {
                // CRITICAL: Preserve /usr/bin and /bin - they contain make, sed, awk, etc.
                if *p == "/usr/bin" || *p == "/bin" || *p == "/usr/local/bin" {
                    return true; // Keep these always
                }
                // Remove only paths that contain gcc/llvm/clang installations
                !(p.contains("/gcc")
                    || p.contains("/g++")
                    || p.contains("/cc")
                    || p.contains("/c++")
                    || p.contains("/llvm")
                    || p.contains("/clang"))
                    && !p.is_empty()
            })
            .collect();

        let new_path = format!(
            "{}{}{}",
            safe_paths.join(":"),
            if filtered_path.is_empty() { "" } else { ":" },
            filtered_path.join(":")
        );

        env_vars.insert("PATH".to_string(), new_path.clone());
        eprintln!("[Patcher] [ENV] Purified PATH: {} and /usr/bin:/bin (removed gcc/llvm/clang installations)", llvm_bin_path);

        // Verify make is available
        if let Ok(make_cmd) = std::process::Command::new("make").arg("--version").output() {
            if make_cmd.status.success() {
                eprintln!("[Patcher] [ENV] ✓ Verified: make command is available");
            } else {
                eprintln!("[Patcher] [ENV] WARNING: make command found but returned non-zero exit");
            }
        } else {
            eprintln!("[Patcher] [ENV] WARNING: make command not found in PATH - build may fail");
        }

        // ============================================================================
        // NATIVE LOCALVERSION EXPORT
        // ============================================================================
        // Export LOCALVERSION as an environment variable for the build system.
        // This ensures the kernel version string is consistent across all build phases.
        // The Makefile will read this and apply it to the final kernel binary name.
        env_vars.insert("LOCALVERSION".to_string(), "".to_string());
        eprintln!("[Patcher] [ENV] Set LOCALVERSION='' (will be configured via .config)");

        env_vars
    }

    /// Injects CFLAGS LTO filters for GPUs.
    /// Delegates to the shared implementation in lto.rs
    /// Uses find_source_file helper to handle nested src/ directories
    pub fn shield_lto(&self, module_names: Vec<String>) -> PatchResult<u32> {
        if module_names.is_empty() {
            return Ok(0); // No shielding needed
        }

        let mut shielded_count = 0u32;

        // Shield each AMD GPU directory
        for shield_dir in AMDGPU_SHIELD_DIRS {
            // Use find_source_file helper to locate Makefile in nested directories
            let relative_makefile_path = format!("{}/Makefile", shield_dir);
            let makefile_path = find_source_file(&self.src_dir, &relative_makefile_path);

            if !makefile_path.exists() {
                eprintln!(
                    "[Patcher] [LTO-SHIELD] Skipping {} - Makefile not found",
                    shield_dir
                );
                continue;
            }

            let content = fs::read_to_string(&makefile_path)
                .map_err(|e| PatchError::PatchFailed(format!("Failed to read Makefile: {}", e)))?;

            // Skip if already shielded
            if content.contains("CFLAGS_amdgpu") && content.contains("filter-out -flto") {
                eprintln!(
                    "[Patcher] [LTO-SHIELD] {} already shielded (idempotent)",
                    shield_dir
                );
                shielded_count += 1;
                continue;
            }

            // Create backup
            let backup_path = self
                .backup_dir
                .join(format!("Makefile.{}.bak", shield_dir.replace('/', "_")));
            fs::create_dir_all(&self.backup_dir).map_err(|e| {
                PatchError::PatchFailed(format!("Failed to create backup dir: {}", e))
            })?;
            fs::write(&backup_path, &content)
                .map_err(|e| PatchError::PatchFailed(format!("Failed to create backup: {}", e)))?;

            // Use shared consolidate implementation from lto.rs
            let updated = lto::shield_amd_gpu_from_lto(&content);

            // Write back the shielded Makefile
            fs::write(&makefile_path, &updated)
                .map_err(|e| PatchError::PatchFailed(format!("Failed to write Makefile: {}", e)))?;

            eprintln!("[Patcher] [LTO-SHIELD] Shielded {} from LTO", shield_dir);
            shielded_count += 1;
        }

        Ok(shielded_count)
    }

    /// Patch root Makefile with persistent toolchain enforcement
    ///
    /// Prepends toolchain enforcement block to the Makefile to ensure
    /// LLVM/Clang is used for all builds, including out-of-tree modules via DKMS.
    ///
    /// # Implementation
    /// - Locates the root Makefile in kernel source using find_source_file helper
    /// - Handles nested src/ directories from makepkg extraction
    /// - Checks if enforcement block already exists (idempotent)
    /// - Prepends LLVM=1, LLVM_IAS=1 export block at file start
    /// - Creates backup of original Makefile
    ///
    /// # Returns
    /// `Ok(())` if patch successful, `Err(PatchError)` if Makefile not found
    pub fn patch_root_makefile(&self) -> PatchResult<()> {
        // Use find_source_file helper to locate root Makefile in nested directories
        let makefile_path = find_source_file(&self.src_dir, "Makefile");

        if !makefile_path.exists() {
            return Err(PatchError::FileNotFound(format!(
                "Makefile not found: {}",
                makefile_path.display()
            )));
        }

        let original_content = fs::read_to_string(&makefile_path)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to read Makefile: {}", e)))?;

        // Check if enforcement block already exists (idempotent)
        if original_content.starts_with("# GOATd Toolchain Enforcement") {
            eprintln!("[Patcher] [MAKEFILE] Toolchain enforcement already present, skipping");
            return Ok(());
        }

        // Create backup
        let backup_path = self.backup_dir.join("Makefile.toolchain.bak");
        fs::create_dir_all(&self.backup_dir)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to create backup dir: {}", e)))?;
        fs::write(&backup_path, &original_content)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to create backup: {}", e)))?;

        // Prepend toolchain enforcement block
        let enforcement_block = r#"# GOATd Toolchain Enforcement
LLVM := 1
LLVM_IAS := 1
export LLVM LLVM_IAS

"#;

        let new_content = format!("{}{}", enforcement_block, original_content);

        fs::write(&makefile_path, &new_content)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to write Makefile: {}", e)))?;

        eprintln!(
            "[Patcher] [MAKEFILE] Prepended toolchain enforcement block (LLVM=1, LLVM_IAS=1)"
        );
        Ok(())
    }

    /// Inject DKMS toolchain configuration to enforce Clang/LLVM for out-of-tree modules
    ///
    /// Creates `/etc/dkms/framework.conf.d/goatd-toolchain.conf` with explicit toolchain
    /// environment variable overrides (CC, CXX, LD, HOSTCC, HOSTCXX) to ensure DKMS
    /// modules use Clang/LLVM instead of GCC.
    ///
    /// This is critical for DKMS module builds to use the same toolchain as kernel builds,
    /// preventing compatibility issues and compiler mismatches.
    ///
    /// # Implementation
    /// - Creates `/etc/dkms/framework.conf.d/` directory with proper permissions (755)
    /// - Writes `goatd-toolchain.conf` with environment variable exports
    /// - File is world-readable but only writable by root
    /// - Idempotent: Only writes if config doesn't already exist
    /// - Logs all operations for debugging and verification
    ///
    /// # Returns
    /// `Ok(())` on success, `Err(PatchError)` on failure
    pub fn inject_dkms_toolchain_config(&self) -> PatchResult<()> {
        use std::process::Command;

        eprintln!("[Patcher] [DKMS] Starting DKMS toolchain configuration injection");

        // Define the DKMS configuration directory and file paths
        let dkms_conf_dir = "/etc/dkms/framework.conf.d";
        let dkms_conf_file = format!("{}/goatd-toolchain.conf", dkms_conf_dir);

        eprintln!(
            "[Patcher] [DKMS] Target configuration file: {}",
            dkms_conf_file
        );

        // STEP 1: Check if we have root privileges (required for /etc operations)
        if unsafe { libc::getuid() } != 0 {
            eprintln!("[Patcher] [DKMS] WARNING: Not running as root - DKMS config injection requires elevated privileges");
            eprintln!("[Patcher] [DKMS] The configuration file will not be created, but this is not fatal");
            eprintln!(
                "[Patcher] [DKMS] DKMS builds may fail if run without proper toolchain environment"
            );
            return Ok(()); // Not an error - gracefully degrade if not root
        }

        // STEP 2: Create /etc/dkms/framework.conf.d directory if it doesn't exist
        eprintln!("[Patcher] [DKMS] Creating directory: {}", dkms_conf_dir);

        // Use mkdir -p with sudo to ensure directory creation with proper permissions
        match Command::new("mkdir").arg("-p").arg(dkms_conf_dir).output() {
            Ok(output) => {
                if output.status.success() {
                    eprintln!(
                        "[Patcher] [DKMS] ✓ Directory created (or already exists): {}",
                        dkms_conf_dir
                    );
                } else {
                    let stderr = String::from_utf8_lossy(&output.stderr);
                    return Err(PatchError::PatchFailed(format!(
                        "Failed to create DKMS config directory: {}",
                        stderr
                    )));
                }
            }
            Err(e) => {
                return Err(PatchError::PatchFailed(format!(
                    "Failed to execute mkdir for DKMS config directory: {}",
                    e
                )));
            }
        }

        // STEP 3: Set proper permissions on the directory (755 - rwxr-xr-x)
        eprintln!("[Patcher] [DKMS] Setting directory permissions to 755");
        match Command::new("chmod").arg("755").arg(dkms_conf_dir).output() {
            Ok(output) => {
                if output.status.success() {
                    eprintln!("[Patcher] [DKMS] ✓ Directory permissions set to 755");
                } else {
                    eprintln!(
                        "[Patcher] [DKMS] WARNING: Failed to set directory permissions (non-fatal)"
                    );
                }
            }
            Err(e) => {
                eprintln!(
                    "[Patcher] [DKMS] WARNING: Failed to chmod directory: {} (non-fatal)",
                    e
                );
            }
        }

        // STEP 4: Construct the DKMS toolchain configuration content
        let config_content = r#"# =====================================================================
# GOATd DKMS Toolchain Configuration
# =====================================================================
# This configuration file ensures that DKMS out-of-tree modules
# use the same Clang/LLVM toolchain as the kernel build.
#
# The toolchain environment variables are forced to Clang/LLVM
# to maintain consistency across native kernel and DKMS builds.
# =====================================================================

# Clang/LLVM toolchain enforcement
export CC=clang
export CXX=clang++
export LD=ld.lld
export HOSTCC=clang
export HOSTCXX=clang++

# LLVM infrastructure support
export LLVM=1
export LLVM_IAS=1

# Standard build tools (LLVM variants)
export AR=llvm-ar
export NM=llvm-nm
export STRIP=llvm-strip
export OBJCOPY=llvm-objcopy
export OBJDUMP=llvm-objdump
export READELF=llvm-readelf
"#;

        // STEP 5: Write the configuration file
        eprintln!(
            "[Patcher] [DKMS] Writing configuration to: {}",
            dkms_conf_file
        );

        match std::fs::write(&dkms_conf_file, config_content) {
            Ok(()) => {
                eprintln!("[Patcher] [DKMS] ✓ Configuration file written successfully");
            }
            Err(e) => {
                return Err(PatchError::PatchFailed(format!(
                    "Failed to write DKMS toolchain config: {}",
                    e
                )));
            }
        }

        // STEP 6: Set proper file permissions (644 - rw-r--r--)
        eprintln!("[Patcher] [DKMS] Setting file permissions to 644");
        match Command::new("chmod")
            .arg("644")
            .arg(&dkms_conf_file)
            .output()
        {
            Ok(output) => {
                if output.status.success() {
                    eprintln!("[Patcher] [DKMS] ✓ File permissions set to 644");
                } else {
                    eprintln!(
                        "[Patcher] [DKMS] WARNING: Failed to set file permissions (non-fatal)"
                    );
                }
            }
            Err(e) => {
                eprintln!(
                    "[Patcher] [DKMS] WARNING: Failed to chmod file: {} (non-fatal)",
                    e
                );
            }
        }

        // STEP 7: Verification - read back the file to ensure it was written correctly
        eprintln!("[Patcher] [DKMS] Verifying configuration file integrity");
        match std::fs::read_to_string(&dkms_conf_file) {
            Ok(content) => {
                if content.contains("export CC=clang") && content.contains("export LLVM=1") {
                    eprintln!("[Patcher] [DKMS] ✓ Verification: Configuration file is valid and contains expected content");
                    eprintln!("[Patcher] [DKMS] SUCCESS: DKMS toolchain configuration injected");
                    Ok(())
                } else {
                    Err(PatchError::PatchFailed(
                        "DKMS config file written but content verification failed".to_string(),
                    ))
                }
            }
            Err(e) => Err(PatchError::PatchFailed(format!(
                "Failed to verify DKMS config file after writing: {}",
                e
            ))),
        }
    }

    /// Strips ICF/LTO flags from root Makefile.
    /// Delegates to the shared implementation in lto.rs
    /// Uses find_source_file helper to handle nested src/ directories
    pub fn remove_icf_flags(&self) -> PatchResult<()> {
        // Use find_source_file helper to locate root Makefile in nested directories
        let makefile_path = find_source_file(&self.src_dir, "Makefile");

        if !makefile_path.exists() {
            return Err(PatchError::FileNotFound(format!(
                "Makefile not found: {}",
                makefile_path.display()
            )));
        }

        let original_content = fs::read_to_string(&makefile_path)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to read Makefile: {}", e)))?;

        // Check if any ICF/LTO flags exist
        if !original_content.contains("--icf")
            && !original_content.contains("-flto=thin")
            && !original_content.contains("-flto=full")
        {
            return Ok(()); // Nothing to remove
        }

        // Create backup
        let backup_path = self.backup_dir.join("Makefile.root.bak");
        fs::create_dir_all(&self.backup_dir)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to create backup dir: {}", e)))?;
        fs::write(&backup_path, &original_content)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to create backup: {}", e)))?;

        // Use shared consolidate implementation from lto.rs
        let content = lto::remove_icf_flags(&original_content);

        // Write back only if changed
        if content != original_content {
            fs::write(&makefile_path, &content)
                .map_err(|e| PatchError::PatchFailed(format!("Failed to write Makefile: {}", e)))?;
        }

        Ok(())
    }

    /// Fix Rust .rmeta and .so installation to use find instead of glob expansion
    ///
    /// CRITICAL FIX FOR CROSS-ENVIRONMENT COMPATIBILITY:
    /// The _package-headers() function uses glob patterns like `rust/*.rmeta` and `rust/*.so`
    /// which fail when those files don't exist (glob expands literally, not as empty set).
    /// This method surgically fixes the installation to use `find` which gracefully handles
    /// missing files across all environments.
    ///
    /// # Returns
    /// Number of fix applications or error if PKGBUILD not found
    pub fn fix_rust_rmeta_installation(&self) -> PatchResult<u32> {
        let pkgbuild_path = self.src_dir.join("PKGBUILD");

        if !pkgbuild_path.exists() {
            return Err(PatchError::FileNotFound(format!(
                "PKGBUILD not found: {}",
                pkgbuild_path.display()
            )));
        }

        let original_content = fs::read_to_string(&pkgbuild_path)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to read PKGBUILD: {}", e)))?;

        // Check if the problematic pattern exists (try both patterns)
        // The glob pattern `rust/*.rmeta` in install command is the problem we're fixing
        if !original_content.contains("rust/*.rmeta") && !original_content.contains("rust/*.so") {
            return Ok(0); // Fix not needed
        }

        // Create backup
        let backup_path = self.backup_dir.join("PKGBUILD.rust_rmeta.bak");
        fs::create_dir_all(&self.backup_dir)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to create backup dir: {}", e)))?;
        fs::write(&backup_path, &original_content)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to create backup: {}", e)))?;

        // Use find with -exec instead of glob expansion
        // CRITICAL: Use RUST_RMETA_FIX template from templates.rs for consistency
        let old_pattern = r#"   echo "Installing Rust files..."
    install -Dt "$builddir/rust" -m644 rust/*.rmeta
    install -Dt "$builddir/rust" rust/*.so"#;

        let new_pattern = templates::RUST_RMETA_FIX;

        let mut content = original_content.clone();

        // Apply the fix if we can find the exact pattern
        if content.contains(old_pattern) {
            content = content.replace(old_pattern, new_pattern);
            eprintln!("[Patcher] [RUST-RMETA] Fixed _package-headers() Rust file installation with safe find pattern");

            fs::write(&pkgbuild_path, &content)
                .map_err(|e| PatchError::PatchFailed(format!("Failed to write PKGBUILD: {}", e)))?;

            return Ok(1);
        }

        // Fallback: Try a more flexible pattern match
        let rmeta_line = "install -Dt \"$builddir/rust\" -m644 rust/*.rmeta";
        let so_line = "install -Dt \"$builddir/rust\" rust/*.so";

        if content.contains(rmeta_line) || content.contains(so_line) {
            let lines: Vec<String> = content
                .lines()
                .map(|line| {
                    if line.trim() == rmeta_line.trim() {
                        "   find rust -maxdepth 1 -type f -name '*.rmeta' -exec install -Dt \"$builddir/rust\" -m644 {} +".to_string()
                    } else if line.trim() == so_line.trim() {
                        "   find rust -maxdepth 1 -type f -name '*.so' -exec install -Dt \"$builddir/rust\" {} +".to_string()
                    } else {
                        line.to_string()
                    }
                })
                .collect();

            content = lines.join("\n");
            if !content.ends_with('\n') {
                content.push('\n');
            }

            eprintln!("[Patcher] [RUST-RMETA] Fixed _package-headers() Rust file installation with flexible pattern");

            fs::write(&pkgbuild_path, &content)
                .map_err(|e| PatchError::PatchFailed(format!("Failed to write PKGBUILD: {}", e)))?;

            return Ok(1);
        }

        Ok(0) // Pattern not found, fix not applied
    }

    /// Surgically remove `-v` flag from all `strip` calls in PKGBUILD
    ///
    /// This targets the incompatibility between llvm-strip and the `-v` flag.
    /// llvm-strip doesn't support `-v` for verbose output, so this method:
    /// - Finds all `strip -v` patterns
    /// - Replaces them with `strip` (removing the flag)
    /// - Creates a backup of the original PKGBUILD
    /// - Ensures safe operation without breaking the build
    ///
    /// # Returns
    ///
    /// Number of replacements made, or error if PKGBUILD not found
    pub fn remove_strip_verbose_flag(&self) -> PatchResult<u32> {
        let pkgbuild_path = self.src_dir.join("PKGBUILD");

        if !pkgbuild_path.exists() {
            return Err(PatchError::FileNotFound(format!(
                "PKGBUILD not found: {}",
                pkgbuild_path.display()
            )));
        }

        let original_content = fs::read_to_string(&pkgbuild_path)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to read PKGBUILD: {}", e)))?;

        // Check if there are any `strip -v` patterns to remove
        if !original_content.contains("strip -v") {
            return Ok(0); // Nothing to remove
        }

        // Create backup
        let backup_path = self.backup_dir.join("PKGBUILD.strip_verbose.bak");
        fs::create_dir_all(&self.backup_dir)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to create backup dir: {}", e)))?;
        fs::write(&backup_path, &original_content)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to create backup: {}", e)))?;

        // Regex patterns to match `strip -v` variations:
        // - Matches `strip -v` with optional spacing
        // - Can be preceded by path or variable expansion
        // - Ensures word boundary to avoid matching strings like "mystrip-v"
        let strip_verbose_regex = Regex::new(r"(?m)\bstrip\s+-v\b")
            .map_err(|e| PatchError::RegexInvalid(format!("Invalid regex: {}", e)))?;

        // Count matches before replacement
        let match_count = strip_verbose_regex.find_iter(&original_content).count() as u32;

        // Replace `strip -v` with `strip`
        let mut content = original_content.clone();
        content = strip_verbose_regex
            .replace_all(&content, "strip")
            .to_string();

        // Write back only if changed
        if content != original_content {
            fs::write(&pkgbuild_path, &content)
                .map_err(|e| PatchError::PatchFailed(format!("Failed to write PKGBUILD: {}", e)))?;
        }

        Ok(match_count)
    }

    /// Patch NVIDIA DKMS configurations to enforce Clang/LLVM toolchain
    ///
    /// Scans `/usr/src` for NVIDIA DKMS driver directories (matching `nvidia-*`)
    /// and patches their `dkms.conf` files to inject `LLVM=1 CC=clang` into MAKE commands.
    ///
    /// # Implementation Strategy
    /// 1. Scan `/usr/src` for directories matching `nvidia-*`
    /// 2. For each NVIDIA source directory, read its `dkms.conf`
    /// 3. Find `MAKE[0]=...` or `MAKE=...` configuration lines
    /// 4. Inject `LLVM=1 CC=clang` into the command if not already present
    /// 5. If no MAKE line exists, append `MAKE[0]="make LLVM=1 CC=clang HOSTCC=clang ..."`
    /// 6. Ensure idempotency by checking for existing `LLVM=1` presence
    /// 7. Handle root privilege requirements gracefully
    /// 8. Log all operations for debugging and verification
    ///
    /// # Requires
    /// - Root privilege (UID 0) to read and write files in `/usr/src`
    /// - NVIDIA DKMS sources to be present in `/usr/src`
    ///
    /// # Idempotency
    /// - Checks if `LLVM=1` is already in the MAKE command before patching
    /// - Skips patching if `LLVM=1` is detected (already applied)
    /// - Creates backups of original dkms.conf files for rollback
    ///
    /// # Returns
    /// Number of NVIDIA DKMS configurations patched, or PatchError on failure
    pub fn patch_nvidia_dkms_config(&self) -> PatchResult<u32> {
        log::info!("[Patcher] [NVIDIA-DKMS-CONFIG] Starting NVIDIA DKMS configuration patching");

        // STEP 1: Check root privilege requirement
        if unsafe { libc::getuid() } != 0 {
            log::warn!("[Patcher] [NVIDIA-DKMS-CONFIG] WARNING: Not running as root - NVIDIA DKMS config patching requires elevated privileges");
            log::warn!(
                "[Patcher] [NVIDIA-DKMS-CONFIG] Skipping NVIDIA DKMS config patches (non-fatal)"
            );
            return Ok(0); // Graceful degradation if not root
        }

        // STEP 2: Scan /usr/src for nvidia-* directories
        log::info!(
            "[Patcher] [NVIDIA-DKMS-CONFIG] Scanning /usr/src for NVIDIA DKMS driver directories"
        );

        let usr_src_path = std::path::PathBuf::from("/usr/src");
        if !usr_src_path.exists() {
            log::warn!("[Patcher] [NVIDIA-DKMS-CONFIG] WARNING: /usr/src does not exist - skipping NVIDIA DKMS config patching");
            return Ok(0);
        }

        let mut patched_count = 0u32;
        let mut nvidia_dirs = Vec::new();

        // Enumerate all directories in /usr/src
        if let Ok(entries) = fs::read_dir(&usr_src_path) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.is_dir() {
                    if let Some(dir_name) = path.file_name() {
                        let name = dir_name.to_string_lossy();
                        if name.starts_with("nvidia-") {
                            log::info!(
                                "[Patcher] [NVIDIA-DKMS-CONFIG] Found NVIDIA source directory: {}",
                                name
                            );
                            nvidia_dirs.push(path);
                        }
                    }
                }
            }
        }

        if nvidia_dirs.is_empty() {
            log::info!("[Patcher] [NVIDIA-DKMS-CONFIG] No NVIDIA DKMS source directories found in /usr/src");
            return Ok(0);
        }

        log::info!(
            "[Patcher] [NVIDIA-DKMS-CONFIG] Found {} NVIDIA source directories",
            nvidia_dirs.len()
        );

        // STEP 3: Process each NVIDIA directory
        for nvidia_dir in nvidia_dirs {
            let dkms_conf_path = nvidia_dir.join("dkms.conf");

            if !dkms_conf_path.exists() {
                log::info!(
                    "[Patcher] [NVIDIA-DKMS-CONFIG] [SKIP] {} - dkms.conf not found",
                    nvidia_dir.display()
                );
                continue;
            }

            // EXACT PATH LOGGING: Clear logging of the dkms.conf file being patched
            let exact_path = dkms_conf_path
                .canonicalize()
                .unwrap_or_else(|_| dkms_conf_path.clone());
            log::info!(
                "[Patcher] [NVIDIA-DKMS-CONFIG] [EXACT-PATH] Processing dkms.conf at: {}",
                exact_path.display()
            );
            log::info!(
                "[Patcher] [NVIDIA-DKMS-CONFIG] [PROCESS] Patching: {}",
                dkms_conf_path.display()
            );

            // Read the original dkms.conf
            let original_content = match fs::read_to_string(&dkms_conf_path) {
                Ok(content) => content,
                Err(e) => {
                    log::error!(
                        "[Patcher] [NVIDIA-DKMS-CONFIG] [ERROR] Failed to read {}: {}",
                        dkms_conf_path.display(),
                        e
                    );
                    continue;
                }
            };

            // STEP 4: Check idempotency - skip if LLVM=1 already present
            if original_content.contains("LLVM=1") {
                log::info!("[Patcher] [NVIDIA-DKMS-CONFIG] [SKIP] {} - LLVM=1 already present (idempotent)", dkms_conf_path.display());
                continue;
            }

            // Create backup before modification
            let backup_path = self.backup_dir.join(format!(
                "dkms.conf.{}.bak",
                nvidia_dir
                    .file_name()
                    .unwrap_or_default()
                    .to_string_lossy()
                    .replace('/', "_")
            ));
            fs::create_dir_all(&self.backup_dir).map_err(|e| {
                PatchError::PatchFailed(format!("Failed to create backup dir: {}", e))
            })?;

            if let Err(e) = fs::write(&backup_path, &original_content) {
                log::warn!(
                    "[Patcher] [NVIDIA-DKMS-CONFIG] [WARNING] Failed to create backup for {}: {}",
                    dkms_conf_path.display(),
                    e
                );
                // Continue anyway - backup failure is non-fatal
            }

            // STEP 5: Find and patch MAKE lines
            let mut new_content = original_content.clone();
            let mut found_make_line = false;

            // Try to find MAKE[0]= or MAKE= line and patch it
            if let Some(caps) = NVIDIA_MAKE_REGEX.captures(&new_content) {
                found_make_line = true;
                let full_match = caps.get(0).unwrap();
                let original_line = full_match.as_str();
                let make_command = caps.get(2).unwrap().as_str().trim();

                log::info!(
                    "[Patcher] [NVIDIA-DKMS-CONFIG] Found MAKE line: {}",
                    original_line
                );

                // Inject LLVM=1 CC=clang at the beginning of the make command
                let patched_line = if make_command.starts_with('"') && make_command.ends_with('"') {
                    // Remove surrounding quotes, inject flags, re-quote
                    let inner = &make_command[1..make_command.len() - 1];
                    format!(r#"MAKE[0]="LLVM=1 CC=clang HOSTCC=clang {}"#, inner)
                } else {
                    format!(r#"MAKE[0]="LLVM=1 CC=clang HOSTCC=clang {}"#, make_command)
                };

                new_content = new_content.replace(original_line, &patched_line);
                log::info!("[Patcher] [NVIDIA-DKMS-CONFIG] Patched MAKE line with LLVM=1 CC=clang");
            }

            // STEP 6: If no MAKE line found, append one
            if !found_make_line {
                log::info!("[Patcher] [NVIDIA-DKMS-CONFIG] No MAKE line found - appending default");

                // Append a properly formatted MAKE[0] line at the end
                if !new_content.ends_with('\n') {
                    new_content.push('\n');
                }
                new_content.push_str(r#"MAKE[0]="make LLVM=1 CC=clang HOSTCC=clang LLVM_IAS=1""#);
                new_content.push('\n');
            }

            // STEP 7: Write the patched configuration back
            if let Err(e) = fs::write(&dkms_conf_path, &new_content) {
                log::error!(
                    "[Patcher] [NVIDIA-DKMS-CONFIG] [ERROR] Failed to write patched dkms.conf: {}",
                    e
                );
                continue;
            }

            log::info!(
                "[Patcher] [NVIDIA-DKMS-CONFIG] [SUCCESS] Patched: {}",
                dkms_conf_path.display()
            );
            patched_count += 1;
        }

        log::info!(
            "[Patcher] [NVIDIA-DKMS-CONFIG] Patched {} NVIDIA DKMS configuration(s)",
            patched_count
        );
        Ok(patched_count)
    }

    /// Apply NVIDIA DKMS compatibility shim for memremap.h (page_free field)
    ///
    /// Kernel 6.19 removed `page_free` from `struct dev_pagemap_ops`.
    /// NVIDIA 590.48.01 (nvidia-open) still references this field, causing DKMS failures.
    /// This method injects a backward compatibility shim into the kernel headers.
    ///
    /// CRITICAL: This shim MUST be applied for NVIDIA DKMS builds to succeed.
    /// The method uses multiple strategies to locate and patch the struct definition,
    /// ensuring the page_free field is restored for out-of-tree module compatibility.
    ///
    /// # Implementation Details
    /// 1. Locates `struct dev_pagemap_ops` in include/linux/memremap.h (source tree)
    /// 2. Uses find_source_file helper to handle nested src/ directories from makepkg
    /// 3. Injects `void (*page_free)(struct page *page);` before struct closing brace
    /// 4. Idempotent: Checks if field already exists to avoid duplicate additions
    /// 5. Tries multiple struct closure patterns to handle kernel version variations
    /// 6. Creates backup of original file for rollback if needed
    ///
    /// # Returns
    /// Number of shims applied (0 or 1) or PatchError on failure
    pub fn apply_nvidia_dkms_memremap_shim(&self) -> PatchResult<u32> {
        // Use find_source_file helper to locate memremap.h in root or nested src/ directories
        let memremap_path = find_source_file(&self.src_dir, "include/linux/memremap.h");

        if !memremap_path.exists() {
            eprintln!(
                "[Patcher] [NVIDIA-DKMS] [CRITICAL] memremap.h not found at: {}",
                memremap_path.display()
            );
            eprintln!("[Patcher] [NVIDIA-DKMS] [WARNING] Skipping NVIDIA DKMS shim - this may cause DKMS failures");
            return Ok(0); // Not a failure - header might not be needed in this kernel
        }

        let original_content = fs::read_to_string(&memremap_path)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to read memremap.h: {}", e)))?;

        eprintln!(
            "[Patcher] [NVIDIA-DKMS] [DEBUG] memremap.h contains {} bytes",
            original_content.len()
        );

        // Check if struct dev_pagemap_ops exists
        if !original_content.contains("struct dev_pagemap_ops") {
            eprintln!(
                "[Patcher] [NVIDIA-DKMS] [WARNING] struct dev_pagemap_ops not found in memremap.h"
            );
            eprintln!("[Patcher] [NVIDIA-DKMS] [WARNING] Skipping shim - this kernel version may not need it");
            return Ok(0); // Not a failure - struct might not exist in this kernel version
        }

        // Check if page_free already exists (idempotent)
        if original_content.contains("page_free") {
            eprintln!("[Patcher] [NVIDIA-DKMS] [INFO] page_free field already present (idempotent - already patched)");
            return Ok(0); // Already patched
        }

        eprintln!("[Patcher] [NVIDIA-DKMS] [INFO] page_free field not found - will inject shim");

        // Create backup
        let backup_path = self.backup_dir.join("memremap.h.nvidia_compat.bak");
        fs::create_dir_all(&self.backup_dir)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to create backup dir: {}", e)))?;
        fs::write(&backup_path, &original_content)
            .map_err(|e| PatchError::PatchFailed(format!("Failed to create backup: {}", e)))?;

        eprintln!(
            "[Patcher] [NVIDIA-DKMS] [BACKUP] Created backup at: {}",
            backup_path.display()
        );

        // Compatibility field definition
        // This is injected into the struct to allow NVIDIA driver to compile
        let compat_member = "    void (*page_free)(struct page *page);  /* NVIDIA DKMS compat: restored for 6.19 */";
        let mut new_content = original_content.clone();

        // =====================================================================
        // STRATEGY 1: Find "} dev_pagemap_ops;" pattern (most specific match)
        // =====================================================================
        eprintln!(
            "[Patcher] [NVIDIA-DKMS] [STRATEGY-1] Looking for struct closing: '}} dev_pagemap_ops'"
        );
        if let Some(pos) = new_content.rfind("} dev_pagemap_ops") {
            eprintln!(
                "[Patcher] [NVIDIA-DKMS] [STRATEGY-1] ✓ Found at position {}",
                pos
            );
            new_content.insert_str(pos, &format!("{}\n", compat_member));

            fs::write(&memremap_path, &new_content).map_err(|e| {
                PatchError::PatchFailed(format!("Failed to write memremap.h: {}", e))
            })?;

            eprintln!("[Patcher] [NVIDIA-DKMS] [STRATEGY-1] ✓ SUCCESS: Injected page_free field (exact match pattern)");
            return Ok(1);
        }
        eprintln!("[Patcher] [NVIDIA-DKMS] [STRATEGY-1] ✗ Pattern not found, trying Strategy 2...");

        // =====================================================================
        // STRATEGY 2: Find "};" within the struct context (fallback for variations)
        // =====================================================================
        eprintln!("[Patcher] [NVIDIA-DKMS] [STRATEGY-2] Looking for struct closing: '}}; pattern");
        if let Some(struct_start) = new_content.rfind("struct dev_pagemap_ops") {
            eprintln!(
                "[Patcher] [NVIDIA-DKMS] [STRATEGY-2] ✓ Found struct at position {}",
                struct_start
            );

            // Find the first closing brace AFTER struct definition (handles opening brace)
            if let Some(closing_pos) = new_content[struct_start..].find("};") {
                let absolute_pos = struct_start + closing_pos;
                eprintln!(
                    "[Patcher] [NVIDIA-DKMS] [STRATEGY-2] ✓ Found closing brace at position {}",
                    absolute_pos
                );
                new_content.insert_str(absolute_pos, &format!("{}\n", compat_member));

                fs::write(&memremap_path, &new_content).map_err(|e| {
                    PatchError::PatchFailed(format!("Failed to write memremap.h: {}", e))
                })?;

                eprintln!("[Patcher] [NVIDIA-DKMS] [STRATEGY-2] ✓ SUCCESS: Injected page_free field (closing brace pattern)");
                return Ok(1);
            }
            eprintln!("[Patcher] [NVIDIA-DKMS] [STRATEGY-2] ✗ Could not find closing brace after struct begin");
        } else {
            eprintln!("[Patcher] [NVIDIA-DKMS] [STRATEGY-2] ✗ struct dev_pagemap_ops not found");
        }

        // =====================================================================
        // STRATEGY 3: Use last "};" as fallback (if struct is at EOF)
        // =====================================================================
        eprintln!(
            "[Patcher] [NVIDIA-DKMS] [STRATEGY-3] Trying fallback: searching for last '}}; in file"
        );
        if let Some(pos) = new_content.rfind("};") {
            eprintln!(
                "[Patcher] [NVIDIA-DKMS] [STRATEGY-3] ✓ Found potential match at position {}",
                pos
            );
            // Verify this is likely the dev_pagemap_ops struct by checking context
            let context_start = if pos > 500 { pos - 500 } else { 0 };
            let context = &new_content[context_start..pos];

            if context.contains("struct dev_pagemap_ops") {
                eprintln!("[Patcher] [NVIDIA-DKMS] [STRATEGY-3] ✓ Context confirms this is dev_pagemap_ops struct");
                new_content.insert_str(pos, &format!("{}\n", compat_member));

                fs::write(&memremap_path, &new_content).map_err(|e| {
                    PatchError::PatchFailed(format!("Failed to write memremap.h: {}", e))
                })?;

                eprintln!("[Patcher] [NVIDIA-DKMS] [STRATEGY-3] ✓ SUCCESS: Injected page_free field (context-aware fallback)");
                return Ok(1);
            }
            eprintln!("[Patcher] [NVIDIA-DKMS] [STRATEGY-3] ✗ Context check failed - not the target struct");
        } else {
            eprintln!("[Patcher] [NVIDIA-DKMS] [STRATEGY-3] ✗ No '}}; pattern found in file");
        }

        // =====================================================================
        // CRITICAL FAILURE: Could not apply shim with any strategy
        // =====================================================================
        eprintln!("[Patcher] [NVIDIA-DKMS] [ERROR] CRITICAL: Could not inject page_free field");
        eprintln!("[Patcher] [NVIDIA-DKMS] [ERROR] Tried 3 strategies with different struct location patterns");
        eprintln!(
            "[Patcher] [NVIDIA-DKMS] [ERROR] Struct found: {}",
            original_content.contains("struct dev_pagemap_ops")
        );
        eprintln!(
            "[Patcher] [NVIDIA-DKMS] [ERROR] This will likely cause NVIDIA DKMS build failures"
        );
        eprintln!(
            "[Patcher] [NVIDIA-DKMS] [ERROR] Backup available at: {}",
            backup_path.display()
        );

        Ok(0) // Return 0 to indicate shim was not applied, but don't fail the build
    }

    /// Main orchestration entry point for the full kernel patching sequence.
    ///
    /// Coordinates all patching sub-modules in the proper order:
    ///
    /// **PHASE 1: PKGBUILD SURGERY**
    ///   - Clang/LLVM toolchain injection
    ///   - Modprobed-db localmodconfig logic
    ///   - Kernel whitelist protection
    ///   - MPL (Metadata Persistence Layer) sourcing
    ///   - Module directory creation (PHASE E2)
    ///   - Kernel variant rebranding
    ///
    /// **PHASE 2: CONFIG MODIFICATION**
    ///   - Kconfig application with Phase 5 LTO hard enforcer
    ///   - .config.override generation for KCONFIG_ALLCONFIG
    ///
    /// **PHASE 3: BUILD SYSTEM PATCHES**
    ///   - AMD GPU LTO shielding
    ///   - Root Makefile LLVM=1 enforcement
    ///   - ICF flag removal
    ///   - Rust .rmeta/.so installation fixes
    ///   - Strip verbose flag removal (llvm-strip compatibility)
    ///
    /// # Arguments
    /// * `shield_modules` - AMD GPU drivers to shield from LTO (deprecated but kept for API compatibility)
    /// * `config_options` - Configuration options to inject into .config
    /// * `build_env_vars` - Build environment variables (GOATD_LTO_LEVEL, GOATD_USE_MODPROBED_DB, etc.)
    ///
    /// # Returns
    /// `Ok(())` on success, `Err(PatchError)` on failure
    pub fn execute_full_patch_with_env(
        &self,
        shield_modules: Vec<String>,
        config_options: HashMap<String, String>,
        build_env_vars: HashMap<String, String>,
    ) -> PatchResult<()> {
        eprintln!("[Patcher] [ORCHESTRATION] Starting Full Kernel Patching Sequence");

        // ====================================================================
        // FORCE CLEAN: WORKSPACE RESET TO KNOWN GOOD STATE
        // ====================================================================
        // CRITICAL: Reset workspace before patching to prevent stale corruption
        // from persisting across build cycles (e.g., corrupted PKGBUILD on Optane mount)
        eprintln!("[Patcher] [FORCE-CLEAN] ========================================");
        eprintln!("[Patcher] [FORCE-CLEAN] INITIATING WORKSPACE FORCE CLEAN");
        eprintln!("[Patcher] [FORCE-CLEAN] Purpose: Reset workspace to known good state");
        eprintln!("[Patcher] [FORCE-CLEAN] Prevents stale/corrupted artifacts from persisting");
        eprintln!("[Patcher] [FORCE-CLEAN] ========================================");

        // STEP 1: Remove old build artifacts (.pkg.tar.zst files)
        eprintln!("[Patcher] [FORCE-CLEAN] STEP 1: Removing old build artifacts");
        match self.cleanup_previous_artifacts() {
            Ok(count) => {
                eprintln!(
                    "[Patcher] [FORCE-CLEAN] ✓ Removed {} old artifact(s)",
                    count
                );
            }
            Err(e) => {
                eprintln!(
                    "[Patcher] [FORCE-CLEAN] ⚠ WARNING: Failed to clean artifacts: {}",
                    e
                );
                // Non-fatal - continue with patching
            }
        }

        // STEP 2: Clean up old patcher backup directory (accumulates over time)
        eprintln!("[Patcher] [FORCE-CLEAN] STEP 2: Cleaning up patcher backup directory");
        if self.backup_dir.exists() {
            match fs::remove_dir_all(&self.backup_dir) {
                Ok(()) => {
                    eprintln!(
                        "[Patcher] [FORCE-CLEAN] ✓ Removed backup directory: {}",
                        self.backup_dir.display()
                    );
                }
                Err(e) => {
                    eprintln!(
                        "[Patcher] [FORCE-CLEAN] ⚠ WARNING: Failed to clean backup dir: {}",
                        e
                    );
                    // Non-fatal
                }
            }
        }

        // STEP 3: Remove .kernelrelease files (will be regenerated after successful build)
        eprintln!("[Patcher] [FORCE-CLEAN] STEP 3: Removing stale .kernelrelease files");
        let kernelrelease_path = self.src_dir.join(".kernelrelease");
        if kernelrelease_path.exists() {
            match fs::remove_file(&kernelrelease_path) {
                Ok(()) => {
                    eprintln!("[Patcher] [FORCE-CLEAN] ✓ Removed stale .kernelrelease");
                }
                Err(e) => {
                    eprintln!(
                        "[Patcher] [FORCE-CLEAN] ⚠ WARNING: Could not remove .kernelrelease: {}",
                        e
                    );
                }
            }
        }

        // STEP 4: Verify PKGBUILD consistency (detect corruption early)
        eprintln!("[Patcher] [FORCE-CLEAN] STEP 4: Verifying PKGBUILD consistency");
        let pkgbuild_path = self.src_dir.join("PKGBUILD");
        if pkgbuild_path.exists() {
            match fs::read_to_string(&pkgbuild_path) {
                Ok(content) => {
                    // Check for corruption markers (e.g., syntax errors)
                    if content.contains("pkgrel()") || content.contains("pkgrel ()") {
                        eprintln!("[Patcher] [FORCE-CLEAN] ✗ CORRUPTION DETECTED: PKGBUILD has malformed pkgrel");
                        eprintln!("[Patcher] [FORCE-CLEAN] This indicates PKGBUILD was corrupted by previous build");
                        eprintln!("[Patcher] [FORCE-CLEAN] Removing for template re-copy on next executor run");
                        match fs::remove_file(&pkgbuild_path) {
                            Ok(()) => {
                                eprintln!("[Patcher] [FORCE-CLEAN] ✓ Removed corrupted PKGBUILD - will be restored from template");
                            }
                            Err(e) => {
                                eprintln!("[Patcher] [FORCE-CLEAN] ⚠ ERROR: Could not remove corrupted PKGBUILD: {}", e);
                                return Err(PatchError::PatchFailed(format!(
                                    "Corrupted PKGBUILD detected but cannot be removed: {}",
                                    e
                                )));
                            }
                        }
                    } else {
                        eprintln!("[Patcher] [FORCE-CLEAN] ✓ PKGBUILD integrity verified (no corruption detected)");
                    }
                }
                Err(e) => {
                    eprintln!(
                        "[Patcher] [FORCE-CLEAN] ⚠ WARNING: Could not verify PKGBUILD: {}",
                        e
                    );
                }
            }
        }

        eprintln!("[Patcher] [FORCE-CLEAN] ========================================");
        eprintln!("[Patcher] [FORCE-CLEAN] WORKSPACE FORCE CLEAN COMPLETE");
        eprintln!("[Patcher] [FORCE-CLEAN] ========================================");

        // ====================================================================
        // DETECT CONFIGURATION FROM ENVIRONMENT
        // ====================================================================

        // Determine LTO Type from environment variable
        let lto_type = match build_env_vars.get("GOATD_LTO_LEVEL").map(|s| s.as_str()) {
            Some("full") => crate::models::LtoType::Full,
            Some("none") => crate::models::LtoType::None,
            _ => crate::models::LtoType::Thin, // Default to Thin
        };
        eprintln!("[Patcher] [ORCHESTRATION] LTO Type: {:?}", lto_type);

        // Determine feature flags from environment
        let use_modprobed = build_env_vars
            .get("GOATD_USE_MODPROBED_DB")
            .map(|v| v == "1")
            .unwrap_or(false);

        let use_whitelist = build_env_vars
            .get("GOATD_USE_KERNEL_WHITELIST")
            .map(|v| v == "1")
            .unwrap_or(false);

        // Extract kernel version and profile for Priority 0 injection
        let kernel_version = build_env_vars
            .get("GOATD_KERNELRELEASE")
            .map(|s| s.as_str());
        let workspace_root = build_env_vars
            .get("GOATD_WORKSPACE_ROOT")
            .map(|s| s.as_str());
        let profile_name = build_env_vars.get("GOATD_PROFILE_NAME").map(|s| s.as_str());

        eprintln!(
            "[Patcher] [ORCHESTRATION] Features: modprobed={}, whitelist={}",
            use_modprobed, use_whitelist
        );
        if let Some(v) = kernel_version {
            eprintln!("[Patcher] [ORCHESTRATION] Kernel Version: {}", v);
        }

        // ====================================================================
        // PHASE 1: PKGBUILD SURGICAL INJECTIONS (Toolchain + Rebranding)
        // ====================================================================
        eprintln!("[Patcher] [ORCHESTRATION] PHASE 1: Starting PKGBUILD surgical injections");

        // PHASE 1.A: Module directory creation with Priority 0 version injection
        eprintln!(
            "[Patcher] [ORCHESTRATION] PHASE 1.A: Injecting module directory creation (PHASE-E2)"
        );
        pkgbuild::inject_module_directory_creation(&self.src_dir, kernel_version)?;

        // PHASE 1.A: DIAGNOSTIC LOGGING
        if let Ok(pkgbuild_content) = fs::read_to_string(self.src_dir.join("PKGBUILD")) {
            if pkgbuild_content.contains("pkgrel") {
                let lines: Vec<&str> = pkgbuild_content.lines().collect();
                for (i, line) in lines.iter().enumerate() {
                    if line.contains("pkgrel") && (line.contains("(") || line.contains("()")) {
                        eprintln!("[Patcher] [PHASE-1.A-DIAG] Found pkgrel line (potentially corrupted): Line {}: {}", i+1, line);
                        // Show context
                        if i > 0 {
                            eprintln!("[Patcher] [PHASE-1.A-DIAG]   Previous: {}", lines[i - 1]);
                        }
                        if i < lines.len() - 1 {
                            eprintln!("[Patcher] [PHASE-1.A-DIAG]   Next: {}", lines[i + 1]);
                        }
                    }
                }
            }
        }

        // PHASE 1.A.1: Environment variable preservation for fakeroot survival
        eprintln!("[Patcher] [ORCHESTRATION] PHASE 1.A.1: Injecting environment variable preservation (fakeroot survival)");
        self.inject_variable_preservation(kernel_version)?;

        // PHASE 1.A.1: DIAGNOSTIC LOGGING
        if let Ok(pkgbuild_content) = fs::read_to_string(self.src_dir.join("PKGBUILD")) {
            if pkgbuild_content.contains("pkgrel") {
                let lines: Vec<&str> = pkgbuild_content.lines().collect();
                for (i, line) in lines.iter().enumerate() {
                    if line.contains("pkgrel") && (line.contains("(") || line.contains("()")) {
                        eprintln!("[Patcher] [PHASE-1.A.1-DIAG] Found pkgrel line (potentially corrupted): Line {}: {}", i+1, line);
                        if i > 0 {
                            eprintln!("[Patcher] [PHASE-1.A.1-DIAG]   Previous: {}", lines[i - 1]);
                        }
                        if i < lines.len() - 1 {
                            eprintln!("[Patcher] [PHASE-1.A.1-DIAG]   Next: {}", lines[i + 1]);
                        }
                    }
                }
            }
        }

        // PHASE 1.B: MPL (Metadata Persistence Layer) sourcing
        if let Some(ws_root) = workspace_root {
            eprintln!(
                "[Patcher] [ORCHESTRATION] PHASE 1.B: Injecting MPL sourcing from workspace: {}",
                ws_root
            );
            pkgbuild::inject_mpl_sourcing(&self.src_dir, std::path::Path::new(ws_root))?;
        } else {
            eprintln!(
                "[Patcher] [ORCHESTRATION] PHASE 1.B: Skipped (GOATD_WORKSPACE_ROOT not set)"
            );
        }

        // PHASE 1.B: DIAGNOSTIC LOGGING
        if let Ok(pkgbuild_content) = fs::read_to_string(self.src_dir.join("PKGBUILD")) {
            if pkgbuild_content.contains("pkgrel") {
                let lines: Vec<&str> = pkgbuild_content.lines().collect();
                for (i, line) in lines.iter().enumerate() {
                    if line.contains("pkgrel") && (line.contains("(") || line.contains("()")) {
                        eprintln!("[Patcher] [PHASE-1.B-DIAG] Found pkgrel line (potentially corrupted): Line {}: {}", i+1, line);
                        if i > 0 {
                            eprintln!("[Patcher] [PHASE-1.B-DIAG]   Previous: {}", lines[i - 1]);
                        }
                        if i < lines.len() - 1 {
                            eprintln!("[Patcher] [PHASE-1.B-DIAG]   Next: {}", lines[i + 1]);
                        }
                    }
                }
            }
        }

        // PHASE 1.C: Clang/LLVM toolchain injection
        eprintln!("[Patcher] [ORCHESTRATION] PHASE 1.C: Injecting Clang/LLVM toolchain exports");
        self.inject_clang_into_pkgbuild()?;

        // PHASE 1.C: DIAGNOSTIC LOGGING
        if let Ok(pkgbuild_content) = fs::read_to_string(self.src_dir.join("PKGBUILD")) {
            if pkgbuild_content.contains("pkgrel") {
                let lines: Vec<&str> = pkgbuild_content.lines().collect();
                for (i, line) in lines.iter().enumerate() {
                    if line.contains("pkgrel") && (line.contains("(") || line.contains("()")) {
                        eprintln!("[Patcher] [PHASE-1.C-DIAG] Found pkgrel line (potentially corrupted): Line {}: {}", i+1, line);
                        if i > 0 {
                            eprintln!("[Patcher] [PHASE-1.C-DIAG]   Previous: {}", lines[i - 1]);
                        }
                        if i < lines.len() - 1 {
                            eprintln!("[Patcher] [PHASE-1.C-DIAG]   Next: {}", lines[i + 1]);
                        }
                    }
                }
            }
        }

        // PHASE 1.D: Modprobed-db localmodconfig logic (if enabled)
        eprintln!(
            "[Patcher] [ORCHESTRATION] PHASE 1.D: Injecting modprobed-db logic (enabled={})",
            use_modprobed
        );
        self.inject_modprobed_localmodconfig(use_modprobed)?;

        // PHASE 1.D: DIAGNOSTIC LOGGING
        if let Ok(pkgbuild_content) = fs::read_to_string(self.src_dir.join("PKGBUILD")) {
            if pkgbuild_content.contains("pkgrel") {
                let lines: Vec<&str> = pkgbuild_content.lines().collect();
                for (i, line) in lines.iter().enumerate() {
                    if line.contains("pkgrel") && (line.contains("(") || line.contains("()")) {
                        eprintln!("[Patcher] [PHASE-1.D-DIAG] Found pkgrel line (potentially corrupted): Line {}: {}", i+1, line);
                        if i > 0 {
                            eprintln!("[Patcher] [PHASE-1.D-DIAG]   Previous: {}", lines[i - 1]);
                        }
                        if i < lines.len() - 1 {
                            eprintln!("[Patcher] [PHASE-1.D-DIAG]   Next: {}", lines[i + 1]);
                        }
                    }
                }
            }
        }

        // PHASE 1.E: Kernel whitelist protection (if enabled)
        eprintln!("[Patcher] [ORCHESTRATION] PHASE 1.E: Injecting kernel whitelist protection (enabled={})", use_whitelist);
        self.inject_kernel_whitelist()?;

        // PHASE 1.E: DIAGNOSTIC LOGGING
        if let Ok(pkgbuild_content) = fs::read_to_string(self.src_dir.join("PKGBUILD")) {
            if pkgbuild_content.contains("pkgrel") {
                let lines: Vec<&str> = pkgbuild_content.lines().collect();
                for (i, line) in lines.iter().enumerate() {
                    if line.contains("pkgrel") && (line.contains("(") || line.contains("()")) {
                        eprintln!("[Patcher] [PHASE-1.E-DIAG] Found pkgrel line (potentially corrupted): Line {}: {}", i+1, line);
                        if i > 0 {
                            eprintln!("[Patcher] [PHASE-1.E-DIAG]   Previous: {}", lines[i - 1]);
                        }
                        if i < lines.len() - 1 {
                            eprintln!("[Patcher] [PHASE-1.E-DIAG]   Next: {}", lines[i + 1]);
                        }
                    }
                }
            }
        }

        // PHASE G1: Prebuild LTO hard enforcer into build()
        eprintln!("[Patcher] [ORCHESTRATION] PHASE G1: Injecting prebuild LTO hard enforcer (lto_type={:?})", lto_type);
        self.inject_prebuild_lto_hard_enforcer(lto_type)?;

        // PHASE G1: DIAGNOSTIC LOGGING
        if let Ok(pkgbuild_content) = fs::read_to_string(self.src_dir.join("PKGBUILD")) {
            if pkgbuild_content.contains("pkgrel") {
                let lines: Vec<&str> = pkgbuild_content.lines().collect();
                for (i, line) in lines.iter().enumerate() {
                    if line.contains("pkgrel") && (line.contains("(") || line.contains("()")) {
                        eprintln!("[Patcher] [PHASE-G1-DIAG] Found pkgrel line (potentially corrupted): Line {}: {}", i+1, line);
                        if i > 0 {
                            eprintln!("[Patcher] [PHASE-G1-DIAG]   Previous: {}", lines[i - 1]);
                        }
                        if i < lines.len() - 1 {
                            eprintln!("[Patcher] [PHASE-G1-DIAG]   Next: {}", lines[i + 1]);
                        }
                    }
                }
            }
        }

        // PHASE G2: Post-modprobed hard enforcer into prepare()
        eprintln!("[Patcher] [ORCHESTRATION] PHASE G2: Injecting post-modprobed hard enforcer (enabled={})", use_modprobed);
        self.inject_post_modprobed_hard_enforcer(use_modprobed)?;

        // PHASE G2: DIAGNOSTIC LOGGING
        if let Ok(pkgbuild_content) = fs::read_to_string(self.src_dir.join("PKGBUILD")) {
            if pkgbuild_content.contains("pkgrel") {
                let lines: Vec<&str> = pkgbuild_content.lines().collect();
                for (i, line) in lines.iter().enumerate() {
                    if line.contains("pkgrel") && (line.contains("(") || line.contains("()")) {
                        eprintln!("[Patcher] [PHASE-G2-DIAG] Found pkgrel line (potentially corrupted): Line {}: {}", i+1, line);
                        if i > 0 {
                            eprintln!("[Patcher] [PHASE-G2-DIAG]   Previous: {}", lines[i - 1]);
                        }
                        if i < lines.len() - 1 {
                            eprintln!("[Patcher] [PHASE-G2-DIAG]   Next: {}", lines[i + 1]);
                        }
                    }
                }
            }
        }

        // PHASE G2.5: Post-setting-config restorer into prepare()
        eprintln!("[Patcher] [ORCHESTRATION] PHASE G2.5: Injecting post-setting-config restorer (enabled={})", use_modprobed);
        self.inject_post_setting_config_restorer(use_modprobed)?;

        // PHASE G2.5: DIAGNOSTIC LOGGING
        if let Ok(pkgbuild_content) = fs::read_to_string(self.src_dir.join("PKGBUILD")) {
            if pkgbuild_content.contains("pkgrel") {
                let lines: Vec<&str> = pkgbuild_content.lines().collect();
                for (i, line) in lines.iter().enumerate() {
                    if line.contains("pkgrel") && (line.contains("(") || line.contains("()")) {
                        eprintln!("[Patcher] [PHASE-G2.5-DIAG] Found pkgrel line (potentially corrupted): Line {}: {}", i+1, line);
                        if i > 0 {
                            eprintln!("[Patcher] [PHASE-G2.5-DIAG]   Previous: {}", lines[i - 1]);
                        }
                        if i < lines.len() - 1 {
                            eprintln!("[Patcher] [PHASE-G2.5-DIAG]   Next: {}", lines[i + 1]);
                        }
                    }
                }
            }
        }

        // PHASE 1.F: Kernel variant rebranding (if profile specified)
        if let Some(profile) = profile_name {
            eprintln!(
                "[Patcher] [ORCHESTRATION] PHASE 1.F: Applying PKGBUILD rebranding (profile={})",
                profile
            );
            pkgbuild::patch_pkgbuild_for_rebranding(&self.src_dir, profile)?;
            
            // PHASE 1.F.2: Inject Polly optimization flags if present
            eprintln!("[Patcher] [ORCHESTRATION] PHASE 1.F.2: Checking for Polly optimization flags");
            pkgbuild::inject_polly_flags(&self.src_dir, &build_env_vars)?;
        } else {
            eprintln!("[Patcher] [ORCHESTRATION] PHASE 1.F: Skipped (GOATD_PROFILE_NAME not set)");
        }

        // PHASE 1.F: DIAGNOSTIC LOGGING
        if let Ok(pkgbuild_content) = fs::read_to_string(self.src_dir.join("PKGBUILD")) {
            if pkgbuild_content.contains("pkgrel") {
                let lines: Vec<&str> = pkgbuild_content.lines().collect();
                for (i, line) in lines.iter().enumerate() {
                    if line.contains("pkgrel") && (line.contains("(") || line.contains("()")) {
                        eprintln!("[Patcher] [PHASE-1.F-DIAG] Found pkgrel line (potentially corrupted): Line {}: {}", i+1, line);
                        if i > 0 {
                            eprintln!("[Patcher] [PHASE-1.F-DIAG]   Previous: {}", lines[i - 1]);
                        }
                        if i < lines.len() - 1 {
                            eprintln!("[Patcher] [PHASE-1.F-DIAG]   Next: {}", lines[i + 1]);
                        }
                    }
                }
            }
        }

        eprintln!("[Patcher] [ORCHESTRATION] PHASE 1: PKGBUILD surgical injections complete");

        // ====================================================================
        // PHASE 2: KERNEL CONFIGURATION MANAGEMENT (Kconfig + Cmdline)
        // ====================================================================
        eprintln!("[Patcher] [ORCHESTRATION] PHASE 2: Starting kernel configuration");

        // PHASE 2.A: Apply Kconfig with Clang/LTO enforcement and baked-in cmdline
        eprintln!(
            "[Patcher] [ORCHESTRATION] PHASE 2.A: Applying Kconfig with Phase 5 LTO hard enforcer"
        );
        self.apply_kconfig(config_options.clone(), lto_type)?;

        // PHASE 2.B: Generate .config.override for KCONFIG_ALLCONFIG safety net
        eprintln!("[Patcher] [ORCHESTRATION] PHASE 2.B: Generating .config.override for native KConfig injection");
        self.generate_config_override(config_options, lto_type)?;

        // PHASE 2.C: Inject modular LOCALVERSION for naming consistency
        if let Some(profile) = profile_name {
            let variant = self
                .detect_kernel_variant()
                .unwrap_or_else(|_| "linux".to_string());
            eprintln!("[Patcher] [ORCHESTRATION] PHASE 2.C: Injecting modular LOCALVERSION (variant={}, profile={})", variant, profile);
            self.inject_modular_localversion(&variant, profile)?;
        }

        eprintln!("[Patcher] [ORCHESTRATION] PHASE 2: Kernel configuration complete");

        // ====================================================================
        // PHASE 3: BUILD SYSTEM PATCHES (Makefile + Build system tweaks)
        // ====================================================================
        eprintln!("[Patcher] [ORCHESTRATION] PHASE 3: Starting final build system patches");

        // PHASE 3.A: AMD GPU LTO shielding (if shield modules specified)
        if !shield_modules.is_empty() {
            eprintln!(
                "[Patcher] [ORCHESTRATION] PHASE 3.A: Shielding {} AMD GPU modules from LTO",
                shield_modules.len()
            );
            let shielded = self.shield_lto(shield_modules)?;
            eprintln!(
                "[Patcher] [ORCHESTRATION] PHASE 3.A: Shielded {} GPU Makefiles",
                shielded
            );
        } else {
            eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.A: Skipped (no shield modules specified)");
        }

        // PHASE 3.B: Patch root Makefile to enforce LLVM=1
        eprintln!(
            "[Patcher] [ORCHESTRATION] PHASE 3.B: Patching root Makefile with LLVM=1 enforcement"
        );
        self.patch_root_makefile()?;

        // PHASE 3.B.1: Inject DKMS toolchain configuration for out-of-tree module enforcement
        eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.B.1: Injecting DKMS toolchain configuration");
        match self.inject_dkms_toolchain_config() {
            Ok(()) => {
                eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.B.1: ✓ DKMS toolchain config injected successfully");
            }
            Err(e) => {
                eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.B.1: WARNING - DKMS config injection failed (non-fatal): {}", e);
                // Continue with patching even if DKMS config fails (may not have root access)
            }
        }

        // PHASE 3.B.2: Patch NVIDIA DKMS configurations (only if NVIDIA GPU detected)
        eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.B.2: Checking for NVIDIA GPU before DKMS config patching");
        let has_nvidia = gpu::detect_gpu_vendor()
            .map(|vendor| vendor == GpuVendor::Nvidia)
            .unwrap_or(false);

        if has_nvidia {
            eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.B.2: NVIDIA GPU detected - patching NVIDIA DKMS driver configurations");
            match self.patch_nvidia_dkms_config() {
                Ok(patched_count) => {
                    eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.B.2: ✓ Patched {} NVIDIA DKMS configuration(s)", patched_count);
                }
                Err(e) => {
                    eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.B.2: WARNING - NVIDIA DKMS config patching failed (non-fatal): {}", e);
                    // Continue with patching even if NVIDIA config fails (may not have root access or NVIDIA sources)
                }
            }
        } else {
            eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.B.2: Skipped - no NVIDIA GPU detected on this system");
        }

        // PHASE 3.C: Remove ICF flags that conflict with LTO
        eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.C: Removing ICF flags from Makefile");
        self.remove_icf_flags()?;

        // PHASE 3.D: Fix Rust .rmeta and .so installation
        eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.D: Fixing Rust .rmeta/.so installation for cross-environment compatibility");
        let rust_fixes = self.fix_rust_rmeta_installation()?;
        eprintln!(
            "[Patcher] [ORCHESTRATION] PHASE 3.D: Applied {} Rust fixes",
            rust_fixes
        );

        // PHASE 3.E: Remove strip -v flag for llvm-strip compatibility
        eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.E: Removing -v flag from strip calls (llvm-strip compatibility)");
        let strip_fixes = self.remove_strip_verbose_flag()?;
        eprintln!(
            "[Patcher] [ORCHESTRATION] PHASE 3.E: Applied {} strip fixes",
            strip_fixes
        );

        // PHASE 3.F: Apply NVIDIA DKMS compatibility shim (only if NVIDIA GPU detected)
        if has_nvidia {
            eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.F: NVIDIA GPU detected - applying NVIDIA DKMS compatibility shim (page_free field restoration)");
            let nvidia_shim_count = self.apply_nvidia_dkms_memremap_shim()?;
            eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.F: Applied {} NVIDIA DKMS shim(s) to source tree", nvidia_shim_count);
        } else {
            eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.F: Skipped - no NVIDIA GPU detected (memremap.h shim not needed)");
        }

        // PHASE 3.G: Inject NVIDIA DKMS shim into headers package function (only if NVIDIA GPU detected)
        if has_nvidia {
            eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.G: NVIDIA GPU detected - injecting NVIDIA DKMS shim into headers package function");
            let header_shim_count = self.inject_nvidia_dkms_shim_into_headers_package()?;
            eprintln!(
                "[Patcher] [ORCHESTRATION] PHASE 3.G: Injected {} header package shim(s)",
                header_shim_count
            );
        } else {
            eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.G: Skipped - no NVIDIA GPU detected (header shim not needed)");
        }

        // PHASE 3.H: Inject post-install repair hook for module symlink integrity (PHASE 15)
        eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.H: Injecting post-install repair hook for module symlinks (PHASE 15)");
        match self.inject_post_install_repair_hook() {
            Ok(()) => {
                eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.H: ✓ Post-install repair hook injected successfully");
            }
            Err(e) => {
                eprintln!("[Patcher] [ORCHESTRATION] PHASE 3.H: WARNING - Post-install repair hook injection failed (non-fatal): {}", e);
                // Continue with patching even if repair hook fails
            }
        }

        eprintln!("[Patcher] [ORCHESTRATION] PHASE 3: Final build system patches complete");

        eprintln!("[Patcher] [ORCHESTRATION] ✓ Full patching sequence completed successfully");
        Ok(())
    }
}

#[cfg(test)]
mod tests;
