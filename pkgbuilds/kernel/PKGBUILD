#!/bin/bash
# Kernel Package Template for GOATd Kernel
# Based on Arch Linux's official linux package

# Package metadata
pkgbase=linux
pkgname=(linux linux-headers)
pkgver=6.12
pkgrel=1
arch=(x86_64)
url="https://github.com/archlinux/linux"
license=(GPL2)
makedepends=(bc libelf pahole python python-sphinx texinfo base-devel git)
options=('!strip')

# Source configuration
_srcname=linux-${pkgver}
source=("https://cdn.kernel.org/pub/linux/kernel/v${pkgver%%.*}.x/linux-${pkgver}.tar.xz")
sha256sums=('SKIP')

# Kernel release will be detected at runtime in package_linux() and package_linux-headers()

prepare() {
    cd $_srcname
    
    # Copy configuration file if it exists
    if [[ -f ../config ]]; then
        cp ../config .config
    fi
    
    # Ensure configuration is consistent with kernel version
    make olddefconfig
    
    # Note: Kernel branding (CONFIG_LOCALVERSION) is applied by the patcher
    # This template is intentionally generic to support rebranding
}

build() {
    cd $_srcname
    # Let the kernel determine its own release string (do NOT override KERNELRELEASE)
    # This allows the actual kernel release to be read from include/config/kernel.release
    make -j$(nproc) all
}

package_linux() {
    cd $_srcname
    
    # CRITICAL FIX: Read actual kernel release from build tree instead of using ${pkgver}-${pkgrel}
    # This ensures the installed kernel matches what the build actually created
    # The kernel's internal release may differ from PKGBUILD's pkgver-pkgrel if CONFIG_LOCALVERSION is set
    local _kernver
    if [ -f include/config/kernel.release ]; then
        _kernver=$(cat include/config/kernel.release)
    else
        # Fallback: query from kernel build
        _kernver=$(make -s kernelrelease)
    fi
    
    # Use the actual kernel release for all installation paths
    make KERNELRELEASE="${_kernver}" INSTALL_MOD_PATH="$pkgdir" modules_install
    
    # Install kernel image
    install -Dm644 arch/x86/boot/bzImage "$pkgdir/boot/vmlinuz-linux"
    
    # Install System.map with actual kernel version
    install -Dm644 System.map "$pkgdir/boot/System.map-${_kernver}"
    
    # Install kernel config with actual kernel version
    install -Dm644 .config "$pkgdir/boot/config-${_kernver}"
    
    # Install kernel release info - CRITICAL: This is the "Source of Truth" for DKMS
    echo "${_kernver}" > "$pkgdir/boot/.kernelrelease"
}

package_linux-headers() {
    cd $_srcname
    make INSTALL_HDR_PATH="$pkgdir/usr" headers_install
    
    # CRITICAL FIX: Read actual kernel release from build tree (Source of Truth for version alignment)
    # Instead of hardcoding ${pkgver}-${pkgrel}, we use the kernel's actual release string
    # This ensures DKMS symlinks in /usr/lib/modules/{_kernver}/build match the installed kernel
    local _kernver
    if [ -f include/config/kernel.release ]; then
        _kernver=$(cat include/config/kernel.release)
    else
        # Fallback: query from kernel build
        _kernver=$(make -s kernelrelease)
    fi
    
    # DKMS package directory - uses actual kernel version, not PKGBUILD version
    local builddir="$pkgdir/usr/src/${pkgbase}-${_kernver}"
    mkdir -p "$builddir"
    
    # Copy critical build infrastructure files for DKMS
    # These are required for out-of-tree module compilation
    cp -a Makefile "$builddir/"
    cp -a Kbuild "$builddir/"
    cp -a .config "$builddir/" 2>/dev/null || true
    
    # Copy Module.symvers for module dependency resolution
    if [ -f Module.symvers ]; then
        cp -a Module.symvers "$builddir/"
    fi
    
    # Copy Scripts directory (contains mod, sign-file, etc.)
    if [ -d scripts ]; then
        mkdir -p "$builddir/scripts"
        cp -a scripts "$builddir/" || true
    fi
    
    # Copy architecture-specific build headers
    # These are essential for DKMS module compilation on target architecture
    if [ -d arch ]; then
        mkdir -p "$builddir/arch"
        cp -a arch "$builddir/" || true
    fi
    
    # Copy tools directory if present (some kernels have it)
    if [ -d tools ]; then
        mkdir -p "$builddir/tools"
        cp -a tools "$builddir/" || true
    fi
    
    # Copy kernel version and build info
    if [ -f include/config/kernel.release ]; then
        mkdir -p "$builddir/include/config"
        cp -a include/config/kernel.release "$builddir/include/config/"
    fi
    
    # Install Rust metadata files using find instead of glob expansion
    # This ensures proper handling when .rmeta or .so files may not exist
    if [ -d rust ]; then
        echo "Installing Rust files..."
        # Use find to safely handle cases where .rmeta or .so files may not exist
        find rust -maxdepth 1 -type f -name '*.rmeta' -exec install -Dt "$builddir/rust" -m644 {} +
        find rust -maxdepth 1 -type f -name '*.so' -exec install -Dt "$builddir/rust" {} +
    fi
    
    # === CRITICAL: Create DKMS symlinks for module compilation ===
    # These symlinks allow DKMS and kernel module compilation to find the build headers.
    # The symlinks must point to the headers directory installed above.
    # This is a required step for DKMS to function correctly on custom kernels like GOATd.
    #
    # CRITICAL FIX: Use actual kernel release (_kernver) instead of hardcoded ${pkgver}-${pkgrel}
    # This ensures the /usr/lib/modules/{_kernver}/build symlink matches the running kernel
    local modules_dir="$pkgdir/usr/lib/modules/${_kernver}"
    mkdir -p "$modules_dir"
    
    # Create /usr/lib/modules/{kernel-release}/build symlink
    # Points to /usr/src/linux-{_kernver} where kernel headers are installed
    # The symlink path MUST match the kernel's actual release string for DKMS to find it
    ln -sf "/usr/src/${pkgbase}-${_kernver}" "$modules_dir/build"
    
    # Create /usr/lib/modules/{kernel-release}/source symlink
    # Points to the same headers directory (required by some module systems)
    ln -sf "/usr/src/${pkgbase}-${_kernver}" "$modules_dir/source"
}
